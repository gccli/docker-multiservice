# A guideline for running multi-service in docker container

虽然[docker](https://docs.docker.com/engine/admin/multi-service_container/)并不推荐在一个容器中启多个服务，但有些场景可能需要，比如通过docker image形式集成提供Rest Api服务的第三方产品，可能第三方产品依赖Nginx, php-fpm, mysql，传统的方式可能将Rest Api服务通过VM image的形式发布，但这并不利于集成方部署，并且比较消耗资源。本文介绍一种在一个docker容器中运行多个服务的方案。

假设我们将实现授权管理服务(LMS):

* LMS以Rest Api提供服务，web app通过php实现，使用Yii框架，依赖web server nginx和php-fpm.
* LMS部署于docker的/opt/lms目录下

## Build lms docker image

docker可以通过[Dockerfile](https://docs.docker.com/engine/reference/builder/)中的指令来自动构建docker image, `Dockerfile`的编写应该严格遵循官方要求的[最佳实践](https://docs.docker.com/engine/userguide/eng-image/dockerfile_best-practices/)

通过docker build命令生成一个docker镜像，此镜像名为lms，tag为latest

    # docker build -t "lms" .
    # docker images
    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE
    lms                 latest              5104e55a6343        13 seconds ago      532.2 MB
    docker.io/centos    latest              328edcd84f1b        6 days ago          192.5 MB


### Dockerfile说明
本例的Dockerfile如下：

```
FROM centos

RUN yum -y install epel-release && rpm -Uvh https://mirror.webtatic.com/yum/el7/webtatic-release.rpm && \
    yum -y install php56w php56w-fpm php56w-cli php56w-common php56w-gd php56w-pdo php56w-mbstring php56w-xml nginx supervisor

COPY lms /opt/lms
COPY supervisord.d/* /etc/supervisord.d/

RUN chown -R nobody /opt/lms/application/web

EXPOSE 443

CMD ["/usr/bin/supervisord", "-n"]
```

1. LMS docker image将centos作为base image, 若未指定docker register源，将从docker.io拉取tag为lastest的centos docker image.
2. RUN将执行任何shell command，本例中有两处RUN(不太符合最佳实践中的Minimize the number of layers)，分别是安装依赖和修改目录权限.
3. 将lms部署到/opt/lms，/opt/lms为LMS的运行环境，目录结构如下：

```
lms
├── application
│   ├── assets
│   ├── commands
│   ├── config
│   ├── controllers
│   ├── models
│   ├── runtime
│   ├── vendor
│   ├── views
│   ├── web
│   ├── widgets
│   ├── yii
│   ├── ...
├── config
│   ├── nginx
│   ├── php-fpm.conf
│   ├── php-fpm.d
│   ├── php.ini
│   └── ssl
├── logs
├── temp
└── var
    ├── php
    └── run
```

3.1) application为web app的代码，LMS的逻辑应在里实现，本例中application正好是[Yii basic template](https://github.com/yiisoft/yii2-app-basic)，通过以下命令安装

    php composer.phar create-project --prefer-dist --stability=dev yiisoft/yii2-app-basic application

3.2) config目录包含nginx, php-fpm的配置文件，其中nginx和php-fpm的worker进程owner配置为nobody;

3.3) logs, temp, var为LMS运行时需要的目录，取决于nginx, php-fpm的配置

4. 本例使用supervisord做为服务的主进程，其子进程nginx, php-fpm的启动配置在supervisord.d目录下，参考[Supervisor配置](http://supervisord.org/configuration.html#program-x-section-settings)
5. EXPOSE，导出LMS对外服务的端口


TODO:

容器中的数据需要持久化，参考[VOLUME](https://docs.docker.com/engine/reference/builder/#volume)和[Use volumes](https://docs.docker.com/engine/admin/volumes/volumes)

 > Volumes are the preferred mechanism for persisting data generated by and used by Docker containers.

## Verify

### Start docker container

    # docker run --name lms1 --privileged=true -p 11443:443 -d -t lms
    c5fb88120a22db7646f953faeb422653fd961926ccf646441baf43554ac71158
    # docker ps
    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                    NAMES
    c5fb88120a22        lms                 "/usr/bin/supervisord"   14 seconds ago      Up 13 seconds       0.0.0.0:11443->443/tcp   lms1


### 进入到运行的docker容器，查询服务状态

    # docker exec -it lms1 /bin/bash
    [root@c5fb88120a22 /]# supervisorctl status
    nginx                            RUNNING   pid 7, uptime 0:02:23
    php-fpm                          RUNNING   pid 8, uptime 0:02:23

### Test RestApi

    curl -k -i https://localhost:11443

## 发布镜像

RestApi自测完成后即可发布镜像，通过以下命令将镜像导出到本地文件lms-VERSION.tar，发送给集成方

    docker save lms -o lms-VERSION.tar
